V8:
NIO基本介绍
NIO 同步非阻塞，相关类再java.nio下，并对原java.io包中的很多类进行了改写
NIO 三大核心部分： Channel(通道),Buffer(缓冲区),Selector(选择器)
NIO 是面向缓冲区或者面向块 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区前后移动，这就增加了处理过程中的灵活性，
                                  使用它可以提供非阻塞式的高伸缩性网络
客户端的数据写入buffer或从buffer读取,buffer通过channel实现与selecotr之间的交互。正因为此，才说NIO是面向缓冲区/面向块                        
client---buffer---channel(read/write)--|
                                       |
client---buffer---channel(read/write)--|----selector-----  thread------| 
                                       |                               |
client---buffer---channel(read/write)--|                               |-----server
client---buffer---channel(read/write)--|                               |
                                       |                               |
client---buffer---channel(read/write)--|----selector-----  thread------| 
                                       | 
client---buffer---channel(read/write)--|

java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果没有可用的数据，就什么也不做，
              而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些
              数据到某个通道，但不需要等待它完全写入，这个线程同时可以去做别的事情----事件驱动非阻塞
              
简单理解：NIO是可以做到一个线程处理多个操作，假设有10000个请求过来，根据实际情况，可以分配50个线程去处理而不用像BIO分配10000个线程
HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级 
V9:案例：将数据写入buffer并且读出

NIO和BIO的比较：1）BIO以流的方式处理数据 NIO以块的方式处理数据，块IO的效率远高于流IO的效率
                2）BIO是阻塞的，NIO是非阻塞的
                3）BIO基于字节流和字符流进行操作，而NIO是基于Channel 和 Buffer进行操作，数据总是从通道读取到缓冲区，或者从缓冲区写入通道。
                            Selector用于监听多个通道的事件（比如：连接请求，数据到达）,因此使用单个线程就可以监听多个客户端通道
  
V10:
NIO 三大核心Selector,Channel ,Buffer 三者的关系
  1) 每个channel都对应一个Buffer
  2) Selector 对应了一个线程，一个Selector对应多个channel
  3) V9视频中的示意图，显示一个了有三个channel注册到了selector程序
  4）程序切换到哪个channel是由事件Event决定的，Event就是一个重要的概念
  5）Selector 会依据不同的事件，在各个通道上切换
** 6）Buffer就是一个内存块，底层是一个数组
  7）数据的读取/写入，是通过buffer,这个和BIO有本质区别。BIO中要不是输入要不是输出，不能双向，但是NIO的buffer是可读可写，但是需要使用flip()切换
  8） channel 是双向的，可以反应底层操作系统的情况，比如 Linux底层操作系统通道就是双向的， 

  
